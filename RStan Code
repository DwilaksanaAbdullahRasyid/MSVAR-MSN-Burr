ibrary(rstan)
library(rstantools)
library(ggplot2)
library(StanHeaders)
library(loo)
library(tseries)
library(MSwM)
library(ggdist)
library(gridExtra)
library(ggExtra)
library(TeachingDemos)
library(openxlsx)
library(imputeTS)

data=read.xlsx("D:\\........xlsx",colNames = TRUE)

EEG_T3_zaim=imputeTS::na_ma(data[,"T3-Cz"], k = 24, weighting = "simple")
EEG_T4_zaim=imputeTS::na_ma(data[,"T4-Cz"], k = 24, weighting = "simple")

data_EEG=read.xlsx("D:\\S3\\proposal DRPM skema penelitian keilmuan 2024\\data EEG RSUA\\zaim\\MK4261KY_noviar III akhir_12;06;16-11;06;26.xlsx",colNames = TRUE)


MSAR_EP='
functions 
  {
      real ep_lpdf(data real y, real mu, real sigma, real beta) {
          real q = 2/(1+beta);
          return (log(1/(2*sigma*q^(1/q)*tgamma(1+1/q)))*exp((-fabs(y-mu)^q)/(q*sigma^q)));
      }
  }
data {
  int T;
  vector[T] y;
}
parameters {
  vector<lower = 0.5, upper = 0.99>[2] p;
  vector<lower = 0.98, upper = 0.99>[2] rho;
  vector[2] alpha;
  vector<lower = -1, upper = 1>[2] beta;
  vector<lower = 0>[2] sigma;
  real<lower = 0, upper = 1> xi1_init; 
  real<lower = 0> y_tm1_init;
}
transformed parameters {
  matrix[T, 2] eta;
  matrix[T, 2] xi;
  vector[T] f;
  vector[T] regime;
  
  // fill in etas
  for(t in 1:T) {
    if(t==1) {
      eta[t,1] = exp(ep_lpdf(y[t]| alpha[1] + rho[1] * y_tm1_init, sigma[1], beta[1]));
      eta[t,2] = exp(ep_lpdf(y[t]| alpha[2] + rho[2] * y_tm1_init, sigma[2], beta[2]));
    } else {
      eta[t,1] = exp(ep_lpdf(y[t]| alpha[1] + rho[1] * y[t-1], sigma[1], beta[1]));
	    eta[t,2] = exp(ep_lpdf(y[t]| alpha[2] + rho[2] * y[t-1], sigma[2], beta[2]));
    }
  }

  
  for(t in 1:T) {
    if(t==1) {
      f[t] = p[1]*xi1_init*eta[t,1] + // stay in state 1
      (1 - p[1])*xi1_init*eta[t,2] + // transition from 1 to 2
      p[2]*(1 - xi1_init)*eta[t,2] + // stay in state 2 
      (1 - p[2])*(1 - xi1_init)*eta[t,1]; // transition from 2 to 1

      xi[t,1] = (p[1]*xi1_init*eta[t,1] +(1 - p[2])*(1 - xi1_init)*eta[t,1])/f[t];
	//xi[t,2] = ((1 - p[1])*xi1_init*eta[t,2] + p[2]*(1 - xi1_init)*eta[t,2])/f[t];
      xi[t,2] = 1.0 - xi[t,1];
      
    } else {
      f[t] = p[1]*xi[t-1,1]*eta[t,1] + // tinggal di regime 1
      (1 - p[1])*xi[t-1,1]*eta[t,2] + // transisi dari regime 1 ke 2
      p[2]*xi[t-1,2]*eta[t,2] + // tinggal di regime 2 
      (1 - p[2])*xi[t-1,2]*eta[t,1]; // transisi dari regime 2 ke 1
      
      xi[t,1] = (p[1]*xi[t-1,1]*eta[t,1] +(1 - p[2])*xi[t-1,2]*eta[t,1])/f[t];
      
	  //xi[t,2] = ((1 - p[1])*xi[t-1,1]*eta[t,2] +p[2]*xi[t-1,2]*eta[t,2])/f[t];
      xi[t,2] = 1.0 - xi[t,1];

    }
	if(xi[t,1]>xi[t,2]){
		regime[t] = 1;
	}
	else{
		regime[t] = 2;
	}
  }
  
}
model {
  // priors
  p ~ normal(0.85, 0.01);
  rho ~ normal(0, .3);
  alpha ~ normal(0, 1); 
  sigma[1] ~ normal(3, 1);
  sigma[2] ~ normal(5, 4);
  beta ~ normal (0, 0.3);
  xi1_init ~ beta(2, 2);
  y_tm1_init ~ normal(0, .1);
  
  
  // perhitungan fungsi likelihood
    target += sum(log(f));
}
'

mod_msar=stan_model(model_code=MSAR_EP,verbose=TRUE)
options(mc.cores = parallel::detectCores())

model_msar2 <- sampling(mod_msar, data= list(T = length(EEG_T3_zaim), y = EEG_T3_zaim), 
                       iter = 100000, chains = 1, algorithm="NUTS", warmup=20000, seed=1122)

print(model_msar2, pars = c("p","rho","lambda","sigma"))

#PLOT REGIME KONVERGEN
regime_converge <- numeric(5000)
# Iterate from 1 to 8760
for (i in 1:5000) {
  # Access the specified object
  result <- model_msar2@sim[["samples"]][[1]][[paste0("regime[", i, "]")]][20000]
  # Store the result in the results vector
  regime_converge[i] <- result
}

#==================
#plotting data time series MSAR MSN BURR
#y=data_fill_na$PM10
y=EEG_T3_zaim
x=1:length(y)
plot(x,y,type="l", ylab="EEG_T3", xlab="Hours in One Year")
regime=as.ts(regime_converge)
#defining color of background
bg_color <- rgb(211/255, 211/255, 211/255, alpha = 0.6)  # Light red
# Finding the indices of values greater than a threshold (e.g., 7) for background color
threshold <- 1.1
highlight_indices <- which(regime < threshold) #regime 1
highlight_indices <- which(regime > threshold) #regime 2
# Adding rectangles for the highlighted regions
for (i in highlight_indices) {
  rect(xleft = x[i] - 0.5, xright = x[i] + 0.5, ybottom = min(y), ytop = max(y), col = bg_color, border = NA)
}
